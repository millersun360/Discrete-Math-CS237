-*- mode: org -*-
#+title: Assignment 03
#+subtitle: DEF Functions
#+language: en
#+options: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t d:(not "HINT")
#+startup: entitiespretty showeverything
#+setupfile: theme-bigblow.setup

:HINT:
 Click your mouse on the links below, or with your cursor somewhere in them,
 press the Enter key.

[[elisp:(relocate-file-to-work-folder)][Relocate File to Work Folder]]

[[elisp:(find-file-other-window "generic-instructions.txt")][Read Instructions]]

[[elisp:(browse-url-of-file (org-html-export-to-html))][Export to HTML and Browse]]

[[elisp:(org-clock-report 1)][Insert/Update Clock Summary Report]]
:END:
* Exercises
** TODO TDR
#+begin_note
  Find the =setf= way of doing the equivalent of =fset=.
#+end_note
#+begin_info
  (fset 'times-2 (lambda(x) (* x 2)))
  becomes
  (fset (symbol-function 'times-2) (lambda(x) (* x 2)))
#+end_info
** TODO WDT
#+begin_note
  PVP the result of evaluating the following (paying special attention to the
  more-than-syntactic difference between the \lsquo{}starless\rsquo{} form of =let= and the
  \lsquo{}star-suffixed\rsquo{} form):

#+begin_src elisp
  (let ((a 1) (b 2) (c 3)) (+ a b c))
#+end_src

#+results:
: 6
  Predict: 6
  Ponder: Pretty straight forward here.

#+begin_src elisp
  (let ((a 1) (b 2) (c 3)) (+ a b c d))

#+end_src
  Prediction: 6
  Ponder: An undefined variable returns an error and kills the program
  (hit ctrl-x ctrl-e to open debugger)

#+begin_src elisp
  (let ((a 1) (b 2) (c 3)) [+ a b c d])
#+end_src

#+results:
: [+ a b c d]

Predict: error-undefined variable
Ponder: square brackets return themselves and whatever is within them

#+begin_src elisp
  (let ((a 1) (b 2) (c 3) (+ 4)) (+ a b c +))
#+end_src

#+results:
: 10

  Prediction: 10
  Pondering: The + symbol is given the value 4

#+begin_src elisp
  (makunbound 'a)
  (let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+end_src
  Predict: 9
  Ponder: Similar to d previously being undefined, a is now undefined

#+begin_src elisp
  (let* ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+end_src

#+results:
: 11

  Predict: 10
  Ponder: I should've realized a (1) was added to d making the total
  sum 9 not 11

#+end_note
#+begin_info

  (let ((a 1) (b 2) (c 3)) (+ a b c))
  Predict: 6
  Verify: 6
  Ponder: Pretty straight forward here.

  (let ((a 1) (b 2) (c 3)) (+ a b c d))
  Prediction: 6
  Verify: error
  Ponder: An undefined variable returns an error and kills the program

  (let ((a 1) (b 2) (c 3)) [+ a b c d])
  Predict: error-undefined variable
  Verify: [+ a b c d]
  Ponder: square brackets return themselves and whatever is within them

  (let ((a 1) (b 2) (c 3) (+ 4)) (+ a b c +))
  Prediction: 10
  Verify: 10
  Pondering: The + symbol is given the value 4

  (makunbound 'a)
  (let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
  Predict: 9
  Verify: error
  Ponder: Similar to d previously being undefined, a is now undefined

  (let* ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
  Predict: 10
  Verify: 11
  Ponder: I should've realized a (1) was added to d making the total
  sum 11 not 10.
#+end_src

#+end_info
** TODO TEJ
#+begin_note
  A function-as-association between elements of a domain and elements of a
  codomain, for \ldquo{}small\rdquo domains and codomains, inspired so-called \ldquo{}association
  lists\rdquo (or alists) and the =assoc= (and associated) functions.

  =(assoc KEY LIST)= returns non-nil if KEY is \ldquo{}equal\rdquo to the first element of
  an element of LIST. The value is actually the first element of LIST whose
  first element equals KEY.

  For example, here is a function that uses an alist to look up the RGB values
  of a given color name:

#+begin_src elisp :results silent
  (defun lookup-rgb (color-name)
    (rest (assoc color-name
                 '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))
#+end_src

#+begin_src elisp :results raw
  (lookup-rgb "blue")
#+end_src

: (0 0 255)

  What if the color name is not in the alist?

#+begin_src elisp :results raw
  (lookup-rgb "grue")
#+end_src

: nil

  There are several variations of =assoc=. Find and give examples of using them.
#+end_note
#+begin_info
#+begin_src elisp
  (assoc-if (lambda (color) (equal (upcase color) "BLUE"))
           '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))
#+end_src

#+results:
| blue | 0 | 0 | 255 |

#+begin_src elisp
  (assoc-if-not (lambda (colorname) (= 3 (length colorname)))
            '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))
#+end_src

#+results:
| green | 0 | 255 | 0 |

#+end_info
** TODO WFK
#+begin_note
  In the function-as-map context, here is another interpretation:

  A \ldquo{}map\rdquo type (AKA associative array, AKA hashtable) is found in many
  languages. For example, C++:
#+begin_src C++ :results output
  #include <iostream>
  #include <map>
  using namespace std;

  int main() {
     map<string, string> mymap;

     mymap["one"] = "red";
     mymap["two"] = "blue";
     mymap["three"] = "green";

     for (auto const &ent1 : mymap) {
        cout << ent1.first << " : " << ent1.second << endl;
     }
  }
#+end_src

: one : red
: three : green
: two : blue

  And python:
#+begin_src python :results output
  mymap = {}

  mymap["one"] = "red"
  mymap["two"] = "blue"
  mymap["three"] = "green"

  if __name__ == "__main__":
          for key in mymap.keys():
                  print key + " : " + str(mymap[key])
#+end_src

: three : green
: two : blue
: one : red

  And of course elisp:
#+begin_src elisp :results output
  (let* ((mymap (make-hash-table :test 'equal)))
    (puthash "one" "red" mymap)
    (puthash "two" "blue" mymap)
    (puthash "three" "green" mymap)
    (pp (list (gethash "one" mymap)
              (gethash "two" mymap)
              (gethash "three" mymap)))
    (maphash (lambda (key value) (princ (format "%s : %s\n" key value))) mymap))
#+end_src

: ("red" "blue" "green")
: one : red
: two : blue
: three : green

  What happens if you omit the =:test 'equal= parameters to the
  =make-hash-table= call?
#+end_note
#+begin_info
#+begin_src elisp :results output
    (let* ((mymap (make-hash-table)))
    (puthash "one" "red" mymap)
    (puthash "two" "blue" mymap)
    (puthash "three" "green" mymap)
    (pp (list (gethash "one" mymap)
              (gethash "two" mymap)
              (gethash "three" mymap)))
    (maphash (lambda (key value) (princ (format "%s : %s\n" key value))) mymap))
#+end_src

#+results:
: (nil nil nil)
: one : red
: two : blue
: three : green

Instead of the :test 'equal parameter, nil is passed in causing there to be no output.

#+end_info
** TODO TER
#+begin_note
  This exercise explores /looping/ versus /mapping/.

  What does the =morphify= function defined below do? Think about it, then PVP
  the result of the call to it that follows.

#+begin_src elisp :results silent
  (defun morphify (fun lst)
    (loop for item in lst
          collect (funcall fun item)))
#+end_src

  Note the quotes:

#+begin_src elisp :results raw
  (morphify (quote downcase) (quote ("THIS" "IS" "TOO" "LOUD")))
#+end_src

#+results:
(this is too loud)

  The =morphify= function is essentially a /mapping/ function, which means it
  takes a passed-in function (=fun=) and a passed-in list (=lst=), and /maps fun
  over lst/, i.e., the results of calling the function =fun= on each element of
  the list =lst= are collected into a new list, which is returned.

  This shows one way (iteratively) a /map/ function could be implemented.
  Another way is /recursively/, as in:

#+begin_src elisp :results silent
  (defun morphifyr (fun lst)
    (if (null lst)
        nil
      (append (list (funcall fun (first lst))) (morphifyr fun (rest lst)))))
#+end_src

  Explain how this version of =morphify= works.
#+end_note
#+begin_info
  Predict: These lines of code are just defining the function morphify so
  it should just return the function
  Verify: The output is "morphify"
  Ponder: It returned the function

  Predict: morphify will change "THIS" "IS" "TOO" "LOUD" into lowercase.
  Verify: The output is "(this is too loud)"
  Ponder: morphify maps the first element over the second, creating a new
  list which is the results of calling the function downcase on each element
  of the list: "THIS" "IS" "TOO" "LOUD"

  Predict: It will run fun on each element of list, but if there is nothing
  in lst then it will append the list with fun and then morphify fun onto it.
  Verify: The output is "morphifyr"
  Ponder: It returned the fuction morphifyr?

#+end_info
** TODO TGE
#+begin_note
  Note the difference if -13 is used instead of 13 below:
#+begin_src elisp :results silent
  (defun compute-floor-the-hard-way (dividend divisor)
    (- (/ dividend (float divisor)) (/ (mod dividend divisor) (float divisor))))
#+end_src

#+begin_src elisp :results raw
  (let* ((number (/ 13 4.0))
         (floor1 (floor number))
         (floor2 (compute-floor-the-hard-way 13 4.0)))
    (list number floor1 floor2))
#+end_src

#+results:
(3.25 3 3.0)

: (3.25 3 3.0)

  Is the hard way correct?
#+end_note
#+begin_info
#+begin_src elisp
    (let* ((number (/ -13 4.0))
         (floor1 (floor number))
         (floor2 (compute-floor-the-hard-way -13 4.0)))
    (list number floor1 floor2))
#+end_src

#+results:
| -3.25 | -4 | -4.0 |
Yes, the hard way is correct because it gives the same answer.
#+end_info
** TODO THP
#+begin_note
  Graph the floor and ceiling functions f(x) = \lfloor{}x\rfloor and f(x) = \lceil{}x\rceil for real
  number values of x in the interval [-5.0 .. 5.0].
#+end_note
#+begin_info
: Graph of Floor
:
:  5                                                             *
:  4                                                       *-----o
:  3                                                 *-----o
:  2                                           *-----o
:  1                                     *-----o
:  0                               *-----o
: -1                         *-----o
: -2                   *-----o
: -3             *-----o
: -4       *-----o
: -5 *-----o
:   -5    -4    -3    -2    -1     0     1     2     3     4     5

: Graph of Ceiling
:
:  5                                                       o-----*
:  4                                                 o-----*
:  3                                           o-----*
:  2                                     o-----*
:  1                               o-----*
:  0                         o-----*
: -1                   o-----*
: -2             o-----*
: -3       o-----*
: -4 o-----*
: -5 *
:   -5    -4    -3    -2    -1     0     1     2     3     4     5
#+end_info
** TODO WKM
#+begin_note
  Which of these statements about floor and ceiling are correct, for any real
  number $x$ and any integers $n$ and $m$?
  1. $x - 1 < \lfloor{}x\rfloor \le x \le \lceil{}x\rceil < x + 1$.
  2. $\lfloor{}-x\rfloor = -\lceil{}x\rceil$.
  3. $\lceil{}-x\rceil = -\lfloor{}x\rfloor$.
  4. $\lfloor{}x + n\rfloor = \lfloor{}x\rfloor + n$.
  5. $\lceil{}x + n\rceil = \lceil{}x\rceil + n$.
  6. $\lfloor{}\frac{n}{2}\rfloor + \lceil{}\frac{n}{2}\rceil = n$.
  7. $\lfloor{}\frac{n}{2}\rfloor + \lfloor{}\frac{n + 1}{2}\rfloor = n$.
  8. $\lceil{}\frac{n}{2}\rceil + \lceil{}\frac{n + 1}{2}\rceil = n$.
  9. $\lfloor{}\frac{n + m}{2}\rfloor + \lceil{}\frac{n - m + 1}{2}\rceil = n$ (for any $m$, not just $m =
     0$ as in statement 7).
  10. $\lceil{}\frac{n + m}{2}\rceil + \lceil{}\frac{n - m + 1}{2}\rceil = n$ (for any $m$, not just $m =
      0$ as in statement 8).
#+end_note
#+begin_info
  1.  True
  2.  True
  3.  True
  4.  True
  5.  True
  6.  True
  7.  True
  8.  False
  9.  True
  10. False
#+end_info
** TODO TIW
#+begin_note
  Define the function \ldquo{}round to nearest integer\rdquo using the floor and ceiling
  functions, together with the \ldquo{}Iverson bracket\rdquo function. (A number whose
  fractional part is less than one-half should be rounded down, otherwise up.)
#+end_note
#+begin_info
#+begin_src emacs-lisp :results silent
  (defun Iverson-bracket (prop)
    (if prop 1 0))

  (defun round-to-nearest-integer (x)
    (if (minusp x)
        (let ((up (ceiling x)))
          (- up (Iverson-bracket (>= (- up x) .5))))
      (let ((down (floor x)))
        (+ down (Iverson-bracket (>= (- x down) .5))))))

#+end_src
#+begin_src emacs-lisp :results raw
 (list (round-to-nearest-integer 3.6)
         (round-to-nearest-integer 3.4)
         (round-to-nearest-integer -3.7)
         (round-to-nearest-integer -3.3))
#+end_src
#+end_info
** TODO TKG
#+begin_note
  Explore the inverse of =assoc= via the functions =rassoc= and associates.
#+end_note
#+begin_info
rassoc - first entry is the key, it is the searched for item in the following list.
#+begin_src elisp :results raw
  (rassoc '(0 255 0)
          '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))
#+end_src

#+results:
(green 0 255 0)

rassoc* - the same, but it supports more key words
#+begin_src elisp
  (rassoc-if (lambda (rgb) (= (second rgb) 255))
             '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))
#+end_src

#+results:
| green | 0 | 255 | 0 |

rassoc-if - Finds the first item whose cdr does not satisfy the Predicate in List
#+begin_src elisp
  (rassoc-if (lambda (rgb) (= (second rgb) 255))
             '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))
#+end_src

#+results:
| green | 0 | 255 | 0 |

rassoc-if-not - Finds the first item whos cdr does NOT satisy the Predicate in List
#+begin_src elisp
  (rassoc-if-not (lambda (rgb) (zerop (third rgb)))
                 '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))
#+end_src

#+results:
| blue | 0 | 0 | 255 |

rassq - finds the element of List that is equivalent to the KEY
#+begin_src elisp
    (rassq 'four '((1 . one) (2 . two) (3 . three) (4 . four) (5 . five)))
#+end_src

#+end_info
** TODO WOV
#+begin_note
  Identify the formula or rule that generates the terms of each sequence:
  1. =[7 14 21 28 35 42 49 56 63 70 ...]=
  2. =[7 11 15 19 23 27 31 35 39 43 ...]=
  3. =[3 4 6 9 13 18 24 31 39 48 ...]=
  4. =[1 10 11 100 101 110 111 1000 1001 1010 ...]=
  5. =[1 1 2 3 5 8 13 21 34 55 ...]=
  6. =[7 22 11 34 17 52 26 13 40 20 ...]=
  7. =[2 1 3 4 7 11 18 29 47 76 ...]=
  8. =[6 12 24 48 96 192 384 768 1536 3072 ...]=
  9. =[6 18 54 162 486 1458 4374 13122 39366 118098 ...]=
  10. =[2 3 5 7 11 13 17 19 23 29 ...]=
#+end_note
#+begin_info
  1. Arithmetic progression with a=7 and d=7.
  2. Arithmetic progression with a=7 and d=4.
  3. Start at 3, add 1 to get 4, then add 2 to 4 to get 6, then add 3 to 6 to
     get 9, then continue each time increasing by one what gets added to each
     term to get the next.
  4. Count up in binary starting at 1.
  5. This is the Fibonacci sequence, the nth term is the nth Fibonacci number.
  6. This is the 3x+1 \ldquo{}orbit of 7\rdquo.
  7. This is the Lucas sequence, the nth term is the nth Lucas number.
  8. These are the powers of two (starting at 2) multiplied by three.
  9. These are the powers of three (starting at 3) multiplied by two.
  10. These numbers are the prime numbers.
#+end_info
** TODO WQW
#+begin_note
  Classify the following lisp functions according as each is or is not a predicate:
  | Predicate? | Yes or No? |
  |------------+------------|
  | =list=       | No         |
  | =listp=      | Yes        |
  | =integerp=   | Yes        |
  | =vector=     | No         |
  | =vectorp=    | Yes        |
  | =symbolp=    | Yes        |
  | =zerop=      | Yes        |
  | =evenp=      | Yes        |
  | =oddp=       | Yes        |
#+end_note
#+begin_info
  | Predicate? | Yes or No? |
  |------------+------------|
  | =list=       | No         |
  | =listp=      | Yes        |
  | =integerp=   | Yes        |
  | =vector=     | No         |
  | =vectorp=    | Yes        |
  | =symbolp=    | Yes        |
  | =zerop=      | Yes        |
  | =evenp=      | Yes        |
  | =oddp=       | Yes        |

#+end_info
** TODO WRP
#+begin_note
  Let P(x) be the statement \ldquo{}x is older than 21 years\rdquo where the domain for x
  consists of all people.

  Express each quantification in English.
  1. $\exists$ x P(x)
  2. $\forall$ x P(x)
  3. $\exists$ x $\neg$ P(x)
  4. $\forall$ x $\neg$ P(x)
#+end_note
#+begin_info
  1. Someone is older than 21.
  2. Everyone is older than 21.
  3. Someone is not older than 21.
  4. Everyone is not older than 21. Or, No one is older than 21.

#+end_info
** TODO TOJ
#+begin_note
  Let S(x) be the statement \ldquo{}x is a student at BYU-Idaho\rdquo where the domain
  consists of the residents of Idaho.

  Express each of these quantifications in English.
  1. $\exists$ x S(x)
  2. $\forall$ x S(x)
  3. $\neg \exists$ x S(x)
  4. $\exists$ x $\neg$ S(x)
  5. $\neg \forall$ x $\neg$ S(x)
  6. $\forall$ x $\neg$ S(x)
#+end_note
#+begin_info
  1. Some resident of Idaho is a student at BYU-Idaho.
  2. Every resident of Idaho is a student at BYU-Idaho.
  3. There is no resident of Idaho who is a student at BYU-Idaho.
  4. There is a resident of Idaho who is not a student at BYU-Idaho.
  5. Not all residents of Idaho are non-students at BYU-Idaho.
  6. Every resident of Idaho is a non-student at BYU-Idaho. Or, No resident of
     Idaho is a student at BYU-Idaho.
#+end_info
** TODO WRU
#+begin_note
  Translate these statements into English, where F(x) is \ldquo{}x is a friend\rdquo,
  C(x) is \ldquo{}x is cool\rdquo, and the domain consists of all people.
  1. $\forall$ x (F(x) $\rightarrow$ C(x))
  2. $\exists$ x (F(x) $\wedge$ C(x))
  3. $\forall$ x (F(x) $\wedge$ C(x))
  4. $\exists$ x (F(x) $\rightarrow$ C(x))
#+end_note
#+begin_info
  1. For all people, if a person is a friend, then that person is cool.
  2. Some person is a friend and is cool.
  3. Every person is a friend and is cool.
  4. For some person, if that person is a friend, then that person is cool.
#+end_info
** TODO TOL
#+begin_note
  Translate these statements into English, where S(x) is \ldquo{}x is a student\rdquo, R(x)
  is \ldquo{}x is from Russia\rdquo, and the domain consists of all people.
  1. $\forall$ x (S(x) $\rightarrow$ R(x))
  2. $\exists$ x (R(x) $\rightarrow$ R(x))
  3. $\forall$ x (S(x) $\wedge$ R(x))
  4. $\exists$ x (S(x) $\wedge$ R(x))
#+end_note
#+begin_info
  1. All students are from Russia.
  2. For some person, if that person is from Russia, then that person is from Russia.
  3. Every person is a student and is from Russia.
  4. Some student is from Russia.
#+end_info
** TODO TUK
#+begin_note
  Translate these statements into English, where the domain for each variable
  consists of all real numbers.
  1. $\exists$ x $\forall$ y (x > y)
  2. $\exists$ x $\exists$ y (((x $\geq$ 0) $\wedge$ (y $\geq$ 0)) $\rightarrow$ (xy $\geq$ 0))
  3. $\exists$ x $\forall$ y $\exists$ z (x = y + z)
#+end_note
#+begin_info
  1. Some number is greater than every number.
  2. The product of some nonnegative numbers is nonnegative.
  3. Some number is the sum of every number and some other number.
#+end_info
** TODO WVQ
#+begin_note
  Let Q(x, y) be the statement \ldquo{}x asks y a question,\rdquo where the domain for both
  x and y consists of all students in a class. Express each quantification in an
  English sentence.
  1. $\forall$ x $\exists$ y Q(x, y)
  2. $\forall$ x $\forall$ y Q(x, y)
  3. $\exists$ x $\exists$ y Q(x, y)
  4. $\exists$ x $\forall$ y Q(x, y)
  5. $\forall$ y $\exists$ x Q(x, y)
  6. $\exists$ y $\exists$ x Q(x, y)
#+end_note
#+begin_info
  1. Every student asks some student a question.
  2. Every student asks every student a question.
  3. Some student asks at least one student a question.
  4. Some student asks every student a question.
  5. Every student is asked a question by some (or at least one) student.
  6. Some student asks some student a question. (Another way to say the answer to 3.)
#+end_info
** TODO TUQ
#+begin_note
  Take the statement Q(x, y) \ldquo{}x asks y a question\rdquo. Express each of these
  sentences in terms of Q(x, y), quantifiers, and logical connectives, where the
  domain for x consists of people at your school, and likewise for y consists of
  people at your school. Use the predicates S(x) = \ldquo{}x is a student\rdquo, T(x) = \ldquo{}x
  is a teacher\rdquo, and A(x) = \ldquo{}x is a TA\rdquo to distinguish different roles for
  people.
  1. No student has ever asked a teacher a question.
  2. There is a student who has asked a teacher a question.
  3. Every student has asked a teacher and a TA a question.
  4. At least two students have asked a teacher a question.
#+end_note
#+begin_info
  1. \forall x \forall y S(x) \land T(y) \rarr \not Q(x, y)
  2. \exists x \exists y S(x) \land T(y) \land Q(x, y)
  3. \forall x \exists y \exists z S(x) \land T(y) \land A(z) \rarr (Q(x y) \land Q(x, z))
  4. \exists x \exists y \exists z S(x) \land S(y) \land x \ne y \land T(z) \land Q(x, z) \land Q(y, z)
#+end_info
** TODO WVU
#+begin_note
  Let the statement T(x, y) \ldquo{}x has taught y\rdquo where the domains for x and y
  consist of all teachers teaching and all classes taught in some department.
  Express each of these sentences in terms of T(x, y), quantifiers, and logical
  connectives.
  1. No teacher has taught every class.
  2. Every teacher has taught every class.
  3. Every teacher has taught some class.
  4. At least two teachers have taught a class.
#+end_note
#+begin_info
  1. \forall x \exists y \not T(x, y)
  2. \forall x \forall y T(x, y)
  3. \forall x \exist y T(x, y)
  4. \exists x_1 \exists x_2 \exists y T(x_1, y) \land T(x_2, y) \land x_1 \ne x_2
#+end_info
** TODO TVL
#+begin_note
  Let D(x, y) be the statement \ldquo{}x has dropped out of y\rdquo where the domain for x
  consists of all students and the domain for y consists of all classes. Express
  each of the statements below as an English sentence.
  1. D(Jackson Andrews, Discrete Mathematics)
  2. $\exists$! x $\forall$ y D(x, y)
  3. $\forall$ x $\exists$ y D(x, y)
#+end_note
#+begin_info
  1. Jackson Andres has dropped out of Discrete Mathematics.
  2. There is one student who has dropped out of every class.
  3. Every student has droped one class.
#+end_info
** TODO TXG
#+begin_note
  What are the truth values of the expressions below if T(x, y) is \ldquo{}xy < y\rdquo,
  where the domain consists of all integers?
  1. T(0, 5)
  2. T(1, 1)
  3. T(7, -3)
  4. $\exists$ x $\forall$ y T(x, y)
  5. $\exists$ x T(x, 2)
  6. $\forall$ y T(9, y)
  7. $\forall$ x $\forall$ y T(x, y)
  8. $\forall$ x $\exists$ y T(x, y)
#+end_note
#+begin_info
  1. True
  2. False
  3. True
  4. True
  5. True
  6. False
  7. False
  8. True
#+end_info
* Problems
  Note: * means optional. If it\rsquo{}s not starred, it\rsquo{}s required.
** TODO TBD *
#+begin_note
  A function is one-to-one if and only if it is onto, /provided/ its domain and
  codomain are the same size.

  Put this statement in symbolic form using the adjectives /injective/ and
  /surjective/, and argue for its truth using the following formal definitions:

  A function from domain A to codomain B

  f : A \rarr B

  is
  - injective :: if f(m) \ne f(n) whenever m \ne n, for all m \in A and for all n \in A;

  and/or is
  - surjective :: if for all b \in B there exists an a \in A such that f(a) = b.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO WDK *
#+begin_note
  Venture further into the /quote/ \ldquo{}macro\rdquo in lisp, used to \ldquo{}suppress\rdquo
  evaluation of symbols, lists and other things. Explore the difference between
  /set/, /setq/ and /setf/ --- /setf/ being another Common Lisp macro (hence the
  need to =(require 'cl)=, as with =loop=) --- and note which feature of
  functional programming is being flouted in this code:

#+begin_src elisp
  (require 'cl)

  (set 'a 'one)
  (setq a (quote one))
  (setf b '(one two))
  (setf a (first b))
  (setf (second b) a)
#+end_src
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO TEH
  Important: see Exercise WDT for context.
#+begin_note
  Could you get by without this star-suffixed form? How?
#+end_note
#+begin_info
  Yes, by nesting the "lets" like,
#+begin_src elisp
   (let ((a 4))
     (let ((b 5))
       (let ((c 6))
         (let ((d (+ a 7)))
           (+ a b c d)))))

#+end_src
#+end_info
** TODO WFC
#+begin_note
  Remembering that these are functions, do the four basic math operators (=+=,
  =-=, =*=, =/=) work as you might expect?

  How about when the number of operands
  - is greater than two?
  - is less than two (i.e., one or zero)?

  This is a good time to mention that functions with arity /n/ for /n/ = 1
  (unary) and /n/ = 2 (binary) have alternate type names, as does a generic
  classification for /n/ > 2:

  | Arity | Type     |
  |-------+----------|
  |     1 | Monadic  |
  |     2 | Dyadic   |
  |   > 2 | Polyadic |

  Argue for /polyadic/ to mean having /arbitrary arity/ (taking 0 /or more/
  arguments).
#+end_note
#+begin_info
Monadic:
#+begin_src elisp
  (+ 4)
#+end_src

#+results:
: 4
#+begin_src elisp
  (- 4)
#+end_src

#+results:
: -4
#+begin_src elisp
  (* 4)
#+end_src

#+results:
: 4
#+begin_src elisp
  (/ 4)
#+end_src

#+results:
: 0

Dyadic:
#+begin_src elisp
  (+ 4 5)
#+end_src

#+results:
: 9
#+begin_src elisp
  (- 4 5)
#+end_src

#+results:
: -1
#+begin_src elisp
  (* 4 5)
#+end_src

#+results:
: 20
#+begin_src elisp
  (/ 4.0 5.0)
#+end_src

#+results:
: 0.8

Polyadic:
#+begin_src elisp
  (+ 4 5 6)
#+end_src

#+results:
: 15
#+begin_src elisp
  (- 4 5 6)
#+end_src

#+results:
: -7
#+begin_src elisp
  (* 4 5 6)
#+end_src

#+results:
: 120
#+begin_src elisp
  (/ 4.0 5.0 6.0)
#+end_src

#+results:
: 0.13333333333333333

Nothing?:
#+begin_src elisp
 (+ )
#+end_src

#+results:
: 0
#+begin_src elisp
  (- )
#+end_src

#+results:
: 0
#+begin_src elisp
  (* )
#+end_src

#+results:
: 1
#+begin_src elisp
  (/ )
#+end_src
(error)

For all basic math operators except for (nothing) polyadic means having arbitary arity but
for / it having 1 or more arguments.

#+end_info
** TODO WGP
  Important: see Exercise TER for context.
#+begin_note
  The =morphify= function already exists by the name =mapcar=, and there are
  several variations and embodiments of this /map/ feature, as you will learn
  (and one of which you have already seen --- where?).

  Write a short (one-line body) lisp function named /vector-to-string/
  that takes a vector of symbols and converts it into a single string of the
  symbols\rsquo{} names separated by a space. for example,

#+begin_src elisp
  (format "%s" (vector-to-string [a b c]))
#+end_src

  should give

: "a b c"

:HINT:
  - Hint ::
#+begin_src elisp
  (let ((info '(("harry" male 42)
                ("larry" male 31)
                ("curly" male 29)
                ("shirley" female 30))))
    (mapconcat 'first info "\n"))
#+end_src
:END:
#+end_note
#+begin_info
#+begin_src elisp
  (defun vector-to-string (vec)
    (mapconcat 'symbol-name vec " "))
#+end_src

#+begin_src elisp
  (format "%S" (vector-to-string [a b c]))
#+end_src

#+results:
: "a b c"

#+end_info
** TODO WGW *
#+begin_note
  Prefix notation takes some getting used to. Converting an expression from
  prefix to infix, to make arithmetic look more \ldquo{}natural\rdquo, is as easy as
  swapping the first two elements of a three-element list; e.g., =(+ 1 2)=
  becomes =(1 + 2)=. But what if the expression has other expressions nested
  within it, e.g., =(- 10 (* 2 3))=, where one (or both) of the operands is
  another 3-element (prefix expression) list? Recursively applying the swapping
  rule is the answer!

  Study the =prefix->infix= function and the three sample calls to it. Describe
  how it works. Try it on more complex expressions. Re-implement it without
  using =let= or =cond= (use =if=).
#+begin_src elisp :results silent
  (defun prefix->infix (pre)
    (cond ((listp pre)
           (or (= 3 (length pre)) (error "not a 3-length list"))
           (let ((operator (nth 0 pre))
                 (operand1 (nth 1 pre))
                 (operand2 (nth 2 pre)))
             (list (prefix->infix operand1)
                   operator
                   (prefix->infix operand2))))
          (t pre)))
#+end_src

#+begin_src elisp :results raw
  (prefix->infix '(+ 1 2))
#+end_src

: (1 + 2)

#+begin_src elisp :results raw
  (prefix->infix '(+ 1 (* 2 3)))
#+end_src

: (1 + (2 * 3))

#+begin_src elisp :results raw
  (prefix->infix '(+ (/ 1 4) (* 2 3)))
#+end_src

: ((1 / 4) + (2 * 3))
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO TFV *
#+begin_note
  Implement and test an =infix->prefix= function.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO WJS
#+begin_note
  Describe an analogous situation to floor when taking the ceiling of negative
  numbers.
#+end_note
#+begin_info
#+begin_src elisp :results raw
  (list (/ -13 4) (ceiling (/ -13 4.0)))
#+end_src

#+results:
(-3 -3)

You would think that the ceiling of a number plus one would be that number.
#+begin_src elisp :results raw
  (list (+ 1 (/ 13 4)) (ceiling (/ 13 4.0)))
#+end_src

#+results:
(4 4)

But with negative numbers this is not true.
#+begin_src elisp :results raw
 (list (+ 1 (/ -13 4)) (ceiling (/ -13 4.0)))
#+end_src

#+results:
(-2 -3)


#+end_info
** TODO WKC
#+begin_note
  Define the \ldquo{}take the fractional part of\rdquo function =frac-part= in terms of
  =floor= as follows:

#+begin_src elisp :results silent
  (defun frac-part (number)
    (- number (floor number)))
#+end_src

  For example,
#+begin_src elisp
  (frac-part 3.14159)
#+end_src

: 0.14158999999999988

  Suppose =frac-part= were the primitive, built-in function. How would you
  define =floor= (assuming it were /not/ built-in) using =frac-part=?
#+end_note
#+begin_info
#+begin_src elisp :results silent
  (defun frac-part (number)
    (- number (floor number)))
#+end_src

#+begin_src emacs-lisp :results silent
  (defun floor-not-primitive (number)
    (truncate (- number (frac-part number))))
#+end_src

#+begin_src emacs-lisp :results raw
  (floor-not-primitive 3.14)
#+end_src

#+results:
3

#+begin_src elisp
  (floor-not-primitive -3.14)
#+end_src

#+results:
: -4

#+end_info
** TODO WNW
#+begin_note
  What conditions/restrictions on a function must be placed for it to be
  /invertible/ (have an inverse)?
#+end_note
#+begin_info
  It must be bijective, meaning each element of one set is paired with exactly one element
  of the other set and visa versa.
#+end_info
** TODO TMZ
#+begin_note
  Write elisp with loops and lambda predicates to answer the following:
  1. How many pairs of numbers between 1 and 1000 pass the predicate given by
     the following lambda expression? (lambda (m n) (= 1 (gcd m n)))
  2. How many solutions are there in integers to the equation 3x + 4y = 7?
  3. Each taken from the set [2 3 4 5 6 7 8 9], how many pairs of numbers are
     there that when multiplied together equal one more than a multiple of 11?
  4. How many pairs of numbers that when multiplied together equal one more than
     a multiple of 23 are found in the set [2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
     17 18 19 20 21]?
  5. How many pairs of numbers that when multiplied together equal one more than
     a multiple of *9* are found in the set [2 3 4 5 6 7]?
#+end_note
#+begin_info
1.
#+begin_src elisp
  (loop with pred = (lambda (m n) (= 1 (gcd m n)))
        for m from 1 to 1000
        sum (loop for n from 1 to 1000
                  count (funcall pred m n)))

;One more time to eliminate duplicates
  (loop with pred = (lambda (m n) (= 1 (gcd m n)))
        for m from 1 to 1000
        sum (loop for n from m to 1000
                  count (funcall pred m n)))
#+end_src

#+results:
: 304192

2. Infinite
3.
#+begin_src elisp
  (loop with pred = (lambda (x y) (= 1 (mod (* x y) 11)))
        for x from 2 to 8
        append (loop for y from (+ x 1) to 9
                     if (funcall pred x y)
                     collect (list x y)))
#+end_src

#+results:
| 2 | 6 |
| 3 | 4 |
| 5 | 9 |
| 7 | 8 |

4.
#+begin_src elisp
  (loop with pred = (lambda (x y) (= 1 (mod (* x y) 23)))
        for x from 2 to 20
        append (loop for y from (+ x 1)to 21
                     if (funcall pred x y)
                     collect (list x y)))
#+end_src

#+results:
|  2 | 12 |
|  3 |  8 |
|  4 |  6 |
|  5 | 14 |
|  7 | 10 |
|  9 | 18 |
| 11 | 21 |
| 13 | 16 |
| 15 | 20 |
| 17 | 19 |

5.
#+begin_src elisp
  (loop with pred = (lambda (x y) (= 1 (mod (* x y) 9)))
        for x from 2 to 20
        append (loop for y from (+ x 1)to 7
                     if (funcall pred x y)
                     collect (list x y)))
#+end_src

#+results:
| 2 | 5 |
| 4 | 7 |

#+end_info
** TODO TNL
#+begin_note
  Explore the counterpart of \Sigma, the symbol used to collapse a /sum/ of terms;
  namely, the Greek letter (which?) used to collapse a /product/ of terms.
#+end_note
#+begin_info
  The counterpart of \Sigma is \Pi
    \Pi^{20}_{n = 1} = (* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)
#+begin_src elisp
  (apply '* (loop for n from 1 to 19 collect n))
#+end_src

#+results:
: 121645100408832000

Alternative approach:
#+begin_src elisp
  (apply '* (number-sequence 1 19))
#+end_src

#+results:
: 121645100408832000

#+end_info
** TODO WRD
#+begin_note
  With at least two examples of a binary function, verify the nested summation
  interchange rule.
#+end_note
#+begin_info

#+begin_src elisp
  (loop for j from 1 to 9
        collect (loop for k from 1 to j
                      collect (list j k)))
#+end_src

#+results:
| (1 1) |       |       |       |       |       |       |       |       |
| (2 1) | (2 2) |       |       |       |       |       |       |       |
| (3 1) | (3 2) | (3 3) |       |       |       |       |       |       |
| (4 1) | (4 2) | (4 3) | (4 4) |       |       |       |       |       |
| (5 1) | (5 2) | (5 3) | (5 4) | (5 5) |       |       |       |       |
| (6 1) | (6 2) | (6 3) | (6 4) | (6 5) | (6 6) |       |       |       |
| (7 1) | (7 2) | (7 3) | (7 4) | (7 5) | (7 6) | (7 7) |       |       |
| (8 1) | (8 2) | (8 3) | (8 4) | (8 5) | (8 6) | (8 7) | (8 8) |       |
| (9 1) | (9 2) | (9 3) | (9 4) | (9 5) | (9 6) | (9 7) | (9 8) | (9 9) |

#+begin_src elisp
  (loop for j from 1 to 9
        collect (loop for k from 1 to j
                      collect (+ j k)))
#+end_src

#+results:
|  2 |    |    |    |    |    |    |    |    |
|  3 |  4 |    |    |    |    |    |    |    |
|  4 |  5 |  6 |    |    |    |    |    |    |
|  5 |  6 |  7 |  8 |    |    |    |    |    |
|  6 |  7 |  8 |  9 | 10 |    |    |    |    |
|  7 |  8 |  9 | 10 | 11 | 12 |    |    |    |
|  8 |  9 | 10 | 11 | 12 | 13 | 14 |    |    |
|  9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |    |
| 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 |

#+begin_src elisp
  (loop for k from 1 to 9
        collect (loop for j from k to 9
                      collect (list j k)))
#+end_src

#+results:
| (1 1) | (2 1) | (3 1) | (4 1) | (5 1) | (6 1) | (7 1) | (8 1) | (9 1) |
| (2 2) | (3 2) | (4 2) | (5 2) | (6 2) | (7 2) | (8 2) | (9 2) |       |
| (3 3) | (4 3) | (5 3) | (6 3) | (7 3) | (8 3) | (9 3) |       |       |
| (4 4) | (5 4) | (6 4) | (7 4) | (8 4) | (9 4) |       |       |       |
| (5 5) | (6 5) | (7 5) | (8 5) | (9 5) |       |       |       |       |
| (6 6) | (7 6) | (8 6) | (9 6) |       |       |       |       |       |
| (7 7) | (8 7) | (9 7) |       |       |       |       |       |       |
| (8 8) | (9 8) |       |       |       |       |       |       |       |
| (9 9) |       |       |       |       |       |       |       |       |


#+begin_src elisp
  (loop for k from 1 to 9
        collect (loop for j from k to 9
                      collect (+ j k)))
#+end_src

#+results:
|  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 |
|  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 |    |
|  6 |  7 |  8 |  9 | 10 | 11 | 12 |    |    |
|  8 |  9 | 10 | 11 | 12 | 13 |    |    |    |
| 10 | 11 | 12 | 13 | 14 |    |    |    |    |
| 12 | 13 | 14 | 15 |    |    |    |    |    |
| 14 | 15 | 16 |    |    |    |    |    |    |
| 16 | 17 |    |    |    |    |    |    |    |
| 18 |    |    |    |    |    |    |    |    |

#+end_info
** TODO TNQ
#+begin_note
  Consider the following function:

#+begin_src elisp :results silent
  (defun calculate-pi-very-slowly (max-iterations)
    (* 4 (loop for n from 0 to max-iterations
               sum (/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))))
#+end_src

  How slow is \ldquo{}very slowly\rdquo?
#+end_note
#+begin_info
#+begin_src elisp
  (defun calculate-pi-very-slowly (max-iterations)
    (* 4 (loop for n from 0 to max-iterations
               sum (/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))))
  (calculate-pi-very-slowly 1000000000)
#+end_src

#+results:
: 3.1425916543395442

#+end_info
** TODO WZO
#+begin_note
  Translate each of these statements into logical expressions using predicates,
  quantifiers, and logical connectives.
  1. Everyone\rsquo{}s a critic.
  2. No one is perfect.
  3. At least one of your friends is perfect.
  4. All of your friends are critics.
  5. Everyone is a critic or someone is your friend.
  6. No one is a critic and everyone is your friend.
#+end_note
#+begin_info
  C(x) = \ldquo{}x is a critic\rdquo, P(x) = \ldquo{}x is perfect\rdquo, F(x) = \ldquo{}x
  is your friend\rdquo
  1. \forall x C(x)
  2. \not \exists x P(x) or \forall x \not P(x)
  3. \exists x F(x) \land P(x)
  4. \forall x F(x) \rarr C(x)
  5. \forall x C(x) \lor \exist x F(x)
  6. \not \exists x C(x) \land \forall x F(x)

#+end_info
** TODO TOU
#+begin_note
  Express each of these statements using quantifiers. Then form the negation of
  the statement so that no negation is to the left of a quantifier. Next,
  express the negation in simple English.
  1. All horses have hooves.
  2. No horses can fly.
  3. Every bat is blind.
  4. No bear can dance.
  5. There is at least one penguin that can swim and catch fish.
#+end_note
#+begin_info
  1. \forall x h(x) \rarr hh(x)
  2. \forall x h(x) \rarr \not cf(x)
  3. \forall x bat(x) \rarr blind(x)
  4. \forall x bear(x) \rarr \not cd(x)
  5. \exists x p(x) \land cs(x) \land ccf(x)

  Negated-
  1. \exists x h(x) \land \not hh(x)
  2. \exists x h(x) \land cf(x)
  3. \exists x bat(x) \land \not blind(x)
  4. \exists x bear(x) \land cd(x)
  5. \forall x \not p(x) \lor \not cs(x) \lor \not ccf(x)

  Negations in English:
  1. A particular horse doesn't have hooves
  2. A particular horse can fly
  3. A particular bat is not blind
  4. A particular bear can dance
  5. Everything is either a non-penguin or can't swim or cant catch fish

#+end_info
** TODO WYH *
#+begin_note
  Express each of these statements using predicates, quantifiers, and logical connectives.
  1. At least one more song, among the nonempty set of songs, can be sung if
     there is a soul alive to music.
  2. Whenever there is an error, at least one error message is displayed.
  3. All the programs have been scanned, but at least one program has a virus.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO TLI
#+begin_note
  The notation $\exists$! x P(x) denotes \ldquo{}There exists a unique x such that P(x) is
  true.\rdquo If the domain consists of all integers, what are the truth values of
  these statements?
  1. $\exists$! x (x > 1)
  2. $\exists$! x (x^2 = 1)
  3. $\exists$! x (x + 3 = 2x)
  4. $\exists$! x (x = x + 1)
#+end_note
#+begin_info
  1. False
  2. False
  3. True
  4. False
#+end_info
** TODO WPI
#+begin_note
  What are the truth values of these statements?
  1. $\exists$! x P(x) $\rightarrow$ $\exists$ x P(x)
  2. $\forall$ x P(x) $\rightarrow$ $\exists$! x P(x)
  3. $\exists$! x $\neg$ P(x) $\rightarrow$ $\neg\forall$ x P(x)
  4. $\forall$ x P(x) $\rightarrow$ $\exists$ x P(x)
#+end_note
#+begin_info
  1. True
  2. True if only one thing exists
  3. True
  4. True provided there is a non-empty universe
#+end_info
** TODO TSD *
#+begin_note
  Let E(x) be the statement \ldquo{}x is an excuse\rdquo, L(x) be the statement \ldquo{}x is a
  lie\rdquo, and R(x) be the statement \ldquo{}x is a reason\rdquo. Suppose that the domain for x
  consists of all English words. Express each of these statements using
  quantifiers, logical connectives, and E(x), L(x), and R(x).
  1. Some excuses are ignored.
  2. Not all lies are reasons.
  3. Some excuses are not reasons.
  4. Some excuses are lies.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO WTM *
#+begin_note
  Let T(x), F(x), R(x), and D(x) be the statements \ldquo{}x is a saint\rdquo, \ldquo{}x is one of
  my friends\rdquo, \ldquo{}x is a soldier\rdquo, and \ldquo{}x is willing to drink\rdquo, respectively.
  Express each of these statements using quantifiers, logical connectives, and
  L(x), M(x), O(x), and D(x).
  1. No saint is willing to drink.
  2. No soldiers ever decline a drink.
  3. All my friends are saints.
  4. My friends are not soldiers.
  5. Does 4 follow logically from 1, 2 and 3? If not, is there a correct
     conclusion?
:HINT:
  - Hint :: This was adapted from a puzzle by Lewis Carroll.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO TTV
#+begin_note
  Determine the truth value of each of these statements if the domain consists
  of all real numbers.
  1. $\exists$ x (x^3 = -9)
  2. $\exists$ x (x^4 > x^2)
  3. $\forall$ x ((-x)^2 = x^2)
  4. $\forall$ x (2x > x)
#+end_note
#+begin_info
  1. True
  2. True
  3. True
  4. False

#+end_info
** TODO WUZ
#+begin_note
  Solidify your knowledge of how looping works in elisp, and then translate the
  following C++ code into elisp:

#+begin_src C++ :results output
/*************************************************************************
,* Quantifiers Example With Unary Predicates
*************************************************************************/
#include <cstdlib>
#include <iomanip>
#include <iostream>
using namespace std;

/**************************************************************
,* The Predicate class is an abstract base class with pure virtual
,* abstract functions (per the =0 suffix).
***************************************************************/
class Predicate
{
public:
   /**************************************************************
   * Is this Predicate true for the given x?
   ***************************************************************/
   virtual bool isTrue(int x)=0;

   /**************************************************************
   * Is this Predicate true for the given x?
   ***************************************************************/
   virtual bool isFalse(int x)=0;

   /**************************************************************
   * Is this Predicate true for all values in the given set?
   ***************************************************************/
   bool forAll(int set[], int size);

   /**************************************************************
   * Is this Predicate true for some value in the given set?
   ***************************************************************/
   bool forSome(int set[], int size);
};

/**************************************************************
,* forAll is A#xP(x) (The Universal Quantification of P(x), the
,* proposition that is true if and only if P(x) is true for all
,* x in the universe of discourse.)
,*
,* loops through all values in a set (of a finite size) to see
,* if the Predicate is always true.  If it encounters a value
,* for which the Predicate is false, then A#xP(x) is false.
,* Otherwise A#xP(x) is true.
***************************************************************/
bool Predicate::forAll(int set[], int size)
{
   for (int i = 0; i < size; i++)
   {
      if (isFalse(set[i]))
      {
         return false;
      }
   }
   return true;
}

/**************************************************************
,* forSome = E#xP(x) (The Existential Quantification of P(x),
,* the proposition that is true if and only if there exists an
,* x in the universe of discourse such that P(x) is true.)
,*
,* loops through all values in a set (of a finite size) to see
,* if the Predicate is ever true.  If it encounters any value
,* for which the Predicate is true, then E#xP(x) is true.
,* Otherwise E#xP(x) is false.
***************************************************************/
bool Predicate::forSome(int set[], int size)
{
   for (int i = 0; i < size; i++)
   {
      if (isTrue(set[i]))
      {
         return true;
      }
   }
   return false;
}

class Even : public Predicate
{
public:
   bool isTrue(int x)
   {
      return ((x % 2) == 0);
   }

   bool isFalse(int x)
   {
      return !isTrue(x);
   }
};

class Odd : public Predicate
{
public:
   bool isTrue(int x)
   {
      return ((x % 2) == 1);
   }

   bool isFalse(int x)
   {
      return !isTrue(x);
   }
};

/**************************************************************
,* main tests for both true and false return values for the
,* two functions forAll and forSome for the simple Predicates
,* Even and Odd.
***************************************************************/
int main()
{
   Even even;
   Odd odd;

   int Evens[] = {0, 2, 4, 6, 8};
   int Odds[] = {1, 3, 5, 7, 9};

   cout << boolalpha << endl;
   cout << "even.forAll(Evens, 5)\n"
        << "     expected to return true;\n"
        << " actual return value is "
        <<  even.forAll(Evens, 5) << ".\n\n";
   cout << "odd.forAll(Evens, 5)\n"
        << "     expected to return false;\n"
        << " actual return value is "
        <<  odd.forAll(Evens, 5) << ".\n\n";
   cout << "even.forAll(Odds, 5)\n"
        << "     expected to return false;\n"
        << " actual return value is "
        <<  even.forAll(Odds, 5) << ".\n\n";
   cout << "odd.forAll(Odds, 5)\n"
        << "     expected to return true;\n"
        << " actual return value is "
        <<  odd.forAll(Odds, 5) << ".\n\n";

   cout << "--------------------------------\n\n";

   cout << "even.forSome(Evens, 5)\n"
        << "     expected to return true;\n"
        << " actual return value is "
        <<  even.forSome(Evens, 5) << ".\n\n";
   cout << "odd.forSome(Evens, 5)\n"
        << "     expected to return false;\n"
        << " actual return value is "
        <<  odd.forSome(Evens, 5)  << ".\n\n";
   cout << "even.forSome(Odds, 5)\n"
        << "     expected to return false;\n"
        << " actual return value is "
        <<  even.forSome(Odds, 5) << ".\n\n";
   cout << "odd.forSome(Odds, 5)\n"
        << "     expected to return true;\n"
        << " actual return value is "
        <<  odd.forSome(Odds, 5)  << ".\n\n";

   return 0;
}
#+end_src

:HINT:
  - Hint :: First make this code NON-object-oriented (purely imperative) by
            using function pointers instead of using a class to encapsulate a
            function. For example:
#+begin_src C++ :results output
#include <cstdlib>
#include <iomanip>
#include <iostream>
using namespace std;

bool oddp(int n) { return ((n % 2) == 1); }

typedef bool (*intPredicate)(int);

int main()
{
   intPredicate pred = oddp;
   cout << boolalpha << pred(5) << endl;
   return 0;
}
#+end_src
:END:
#+end_note
#+begin_info

#+end_info
** TODO WZM *
#+begin_note
  Write the definitions of /injective/ and /surjective/ given in TBD
  using quantifier symbols instead of words.
:HINT:
  - Hint :: Recall that \lsquo{}for all\rsquo or \lsquo{}for every\rsquo is Universal ($\forall$), and \lsquo{}for
            some\rsquo or \lsquo{}there exists\rsquo is Existential ($\exist$).
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO TUW
#+begin_note
  Use quantifiers and predicates with more than one variable to express these statements.
  1. Every CS major needs to take discrete mathematics.
  2. Every student in the class owns a laptop.
  3. There is a student in the class who has taken data structures.
  4. No student has been in every building at the University.
  5. Exactly one student has been in every room of the STC.
  6. Every student has been in at least one room of every building on campus.
#+end_note
#+begin_info
  KEY:
  CSM(x) = x is a CS major
  NT(x, y) = x needs to take y
  SIC(x) = x is a student in the class
  O(x, y) = x owns y
  HT(x, y) = x has taken y
  S(x) = x is a student
  R(x) = x is a room
  HBI(x, y) = x has been in y
  IB(x) = x is a building at the University (on campus
  II(x, y) = x is in y
  STATEMENTS:
  1. \forall x CSM(x) \rarr NT(x, discrete mathematics)
  2. \forall x SIC(x) \rarr O(x, laptop)
  3. \exists x SIC(x) \land HT(x, data structures)
  4. \forall x \exists y [S(x) \land IB(y) \land \not HBI(x, y)]
  5. \exists! x \forall y [(S(x) \land R(y) \land II(y, STC)) \rarr HBI(x, y)]
  6. \forall x \exists y \forall z [(S(x) \land R(y)) \rarr (IB(z) \rarr HBI(x, y))]

#+end_info
** TODO WWD *
#+begin_note
  Use quantifiers and predicates with more than one variable to express the
  /negations/ of these statements:
  1. Every CS major needs to take discrete mathematics.
  2. Every student in the class owns a laptop.
  3. There is a student in the class who has taken data structures.
  4. No student has been in every building at the University.
  5. Exactly one student has been in every room of the STC.
  6. Every student has been in at least one room of every building on campus.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO WWR *
#+begin_note
  Express each of these statements using predicates, quantifiers, logical
  connectives, and mathematical operators where the domain consists of all
  integers.
  1. The average of two numbers is not greater than those two numbers.
  2. The product of a positive number and a negative number is negative.
  3. There is no solution for a number divided by zero.
  4. All positive numbers are greater than all negative numbers.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO TWN *
#+begin_note
  Express the statement \ldquo{}no prime number has 3 factors\rdquo using predicates,
  quantifiers, logical connectives, and mathematical operators.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO WWS
#+begin_note
  If the domain consists of all integers, what are the truth values of these statements?
  1. $\forall$ x $\forall$ y (x $\neq$ 0) $\wedge$ (y $\neq$ 0) $\leftrightarrow$ (xy $\neq$ 0)
  2. $\exists$ x $\forall$ y (x + y > y)
  3. $\exists$ x $\forall$ y (x + y < y)
  4. $\exists$! x $\forall$ y (x + y = y)
#+end_note
#+begin_info
  1. True
  2. True
  3. True
  4. True

#+end_info
** TODO WZG *
#+begin_note
  Determine the truth value of the statement

  $\forall$ x $\exists$ y (x - y $\geq$ x)

  if the domain for x and y consists of
  1. all real numbers.
  2. the natural numbers.
  3. all negative integers.
  4. rational numbers.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO TKH
#+begin_note
  Expand to two nested quantifiers the code you created for one quantifier.

  Specifically, implement these four functions, shown side-by-side with their
  symbolic logic equivalents:

  | Function Name     | In Symbols  |
  |-------------------+-------------|
  | for-all-for-all   | $\forall{}$ x $\forall{}$ y |
  | for-all-for-some  | $\forall{}$ x $\exists{}$ y |
  | for-some-for-all  | $\exists{}$ x $\forall{}$ y |
  | for-some-for-some | $\exists{}$ x $\exists{}$ y |

  Let\rsquo{}s examine these quantifications in the context of loops and a generic
  predicate P. These will be /nested/ loops, an outer one wrapping an inner one,
  because /nested/ quantification is what is being expressed. The predicate
  (function) call (P x y) goes in the inner loop, which controls the y, while
  the outer loop controls the x.

  \ldquo{}For all x for all y\rdquo wants to find (P x y) always true. That\rsquo{}s what it means
  for the nested quantification to be true, and naturally, this only works if
  the domains of x and y are finite. Even then, it really only /works/ if these
  domains are reasonably finite --- not /too/ big. Iteration is serial, after
  all, and time is short.

  So, for-all-for-all loops through x\rsquo{}s domain, and for each x loops through
  each y in y\rsquo{}s domain. On each inner-loop iteration it calls (P x y) and checks
  the value. If the value is ever false, then for-all-for-all is false ---
  immediately --- no need to check any further. Some y has been found for some x
  where the predicate is false. If both loops finish with nary a false
  evaluation, for-all-for-all is ultimately true. There is no x for which, for
  any y, (P x y) is false.

  The other function with similarly relatively simple logic is
  for-some-for-some. This function loops through x\rsquo{}s domain, and for each x
  loops through each y in y\rsquo{}s domain. On each inner-loop iteration it calls (P x
  y) and checks the value. If a true value is found, then for-some-for-some is
  true --- immediately --- no need to check any further. If both loops finish
  never having triggered true, for-some-for-some is ultimately false. There is
  no x for which there is some y for which (P x y) is true.

  The other two are trickier. \ldquo{}For all x for some y\rdquo wants (P x y) to always be
  true sometimes, and \ldquo{}for some x for all y\rdquo wants (P x y) to sometimes be true
  always. Implement for-all-for-some and for-some-for-all the best, most elegant
  way you can.

  Test your implementations of these four functions using a suitable binary
  (arity 2) predicate, for example =>=.
:HINT:
  - Hint :: See WUZ for the context.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO WUE
#+begin_note
  Consider Doctrine and Covenants 130:20-21 in light of what you know of
  predicates and quantifiers:

  - 20. :: /There is a law, irrevocably decreed in heaven before the foundations
           of this world, upon which all blessings are predicated./
  - 21. :: /And when we obtain any blessing from God, it is by obedience to that
           law upon which it is predicated./

  Given the predicate $P(x, y)$ = \ldquo{}blessing $x$ is predicated on law \(y\)\rdquo,
  these two verses are best expressed as a quantified statement by which of the
  following?

  1. $\forall\,x\,\forall\,y\,P(x, y)$
  2. $\forall\,x\,\exists\,y\,P(x, y)$
  3. $\exists\,x\,\forall\,y\,P(x, y)$
  4. $\exists\,x\,\exists\,y\,P(x, y)$

  Justify your choice.
#+end_note
#+begin_info
  $\forall\,x\,\exists\,y\,P(x, y)$
  For every blessing we recieve there is soe law upon which it is predicated.
#+end_info
* Puzzles
** TODO TEU
#+begin_note
  How many numbers between one and a million contain the digit 1 exactly once,
  and the sum of the rest of the digits is 16? Write elisp code with and without
  loops to verify your answer.
#+end_note
*** Rephrase
    Write some elisp code to loop through the numbers 1 to 1000000 and output the amount of
    numbers which contain '1' exactly once in all their digits which also all add up to 17
*** Approach
    Modularize with and without loops
*** Solution
#+begin_src elisp :results silent
  (require 'cl)

  (defun list-of-digits (n)
    (if (= n 0) nil
      (append (list-of-digits (/ n 10)) (list (% n 10)))))

  (defun sum-of-digits (n)
    (apply '+ (list-of-digits n)))

  (defun how-many-in (digit digit-list)
    (loop for n in digit-list
          count (= n digit)))

  (defun how-many-in-with-map (digit digit-list)
     (apply '+ (mapcar (lambda (n) (if (= n digit) 1 0)) digit-list)))

  (defun has-one (digit digit-list)
    (= 1 (how-many-in digit digit-list)))

  (defun filter (n)
    (let ((digits (list-of-digits n)))
      (and (has-one 1 digits) (= 17 (apply '+ digits)))))

  (defun get-answer ()
    (loop for n from 1 to 999999
          count (filter n)))

  (defun get-answer-with-map ()
    (let ((sum 0))
      (mapc (lambda (n) (if (filter n) (incf sum)))
            (number-sequence 1 999999))
      sum))
#+end_src

#+begin_src elisp
  (list (get-answer) (get-answer-with-map))
#+end_src

#+results:
| 9150 | 9150 |

*** Proof
    See above.
** TODO TME
#+begin_note
  Sequences can be non-numeric as well. What is the pattern for this sequence?
: [m b w y me be wi yo met bew ith you meta bewi thyo uati metap bewit hyoua tirel]
  How long can it continue?
#+end_note
*** Rephrase
    What is the pattern for this sequence?
    : [m b w y me be wi yo met bew ith you meta bewi thyo uati metap bewit hyoua tirel]
    How long can it continue
*** Approach
    First I noticed that every four words there is an increasing amount of letters by one.
    Then I noticed that a set of four words contained the same letters as the sets before it.
    Then I organized the sets into columns so it looks like this.
    m b w y
    me be wi yo
    met bew ith you
    meta bewi thyo uati
    metap bewit hyoua tirel
    Following this pattern I new there needed to be another set of four unknown letters to be
    added onto each element. But what letters? It was at this point I realized that it likened
    the title of this courses book.
*** Solution
    Every four words a letter is added onto each word. Some more iterations would lead one to
    this:
    metaph bewith youati reless
    metapho bewithy ouatire lesswor
    metaphor bewithyo uatirele ssworkon
    methaphors bewithyou atireless workonpla onwords
*** Proof
    See above.
** TODO WRA
#+begin_note
  Why is the sum of the reciprocals of the powers of two scaled by which power
  equal to two?
#+end_note
*** Rephrase
    Why does \sum^\infty_{n=0} n/2^n = 2?
*** Approach`
    Write out the first few iterations of the fraction and identify the pattern to code.
*** Solution
    | 1/2 | + | 1/4 | + | 1/8 | + | 1/16 | + | ... | = | 1/1 |
    |     | + | 1/4 | + | 1/8 | + | 1/16 | + | ... | = | 1/2 |
    |     |   |     | + | 1/8 | + | 1/16 | + | ... | = | 1/4 |
    |     |   |     |   |     |   | 1/16 | + | ... | = | 1/8 |
    The sum of the last column (continued) is the sum of the reciprocals of the powers of two.
*** Proof
#+begin_src elisp :results silent
  (defun the-big-boy (iterations)
    (loop for n from 1 to iterations
          sum (/ n (expt 2.0 n))))
#+end_src
#+begin_src elisp
  (the-big-boy 10000000)
#+end_src

#+results:
: 1.9999999999999998


** TODO MMP (not in book)
#+begin_note
   What is the following code demonstrating?
#+begin_src elisp :results silent
  (defun mm (m1 m2)
    "
    Multiplication of 2x2 matrices works as follows:
    | a b |   | e f |   | a*e + b*g   a*f + b*h |
    |     | x |     | = |                       |
    | c d |   | g h |   | c*e + d*g   c*f + d*h |
  "
    (let* ((ab (elt m1 0))
           (cd (elt m1 1))
           (ef (elt m2 0))
           (gh (elt m2 1))
           (a (elt ab 0))
           (b (elt ab 1))
           (c (elt cd 0))
           (d (elt cd 1))
           (e (elt ef 0))
           (f (elt ef 1))
           (g (elt gh 0))
           (h (elt gh 1)))
      (vector (vector (+ (* a e) (* b g))
                      (+ (* a f) (* b h)))
              (vector (+ (* c e) (* d g))
                      (+ (* c f) (* d h))))))
#+end_src

#+begin_src elisp :results raw
  (rest (rest (rest (symbol-function 'mm))))
#+end_src

#+results:
((let* ((ab (elt m1 0)) (cd (elt m1 1)) (ef (elt m2 0)) (gh (elt m2 1)) (a (elt ab 0)) (b (elt ab 1)) (c (elt cd 0)) (d (elt cd 1)) (e (elt ef 0)) (f (elt ef 1)) (g (elt gh 0)) (h (elt gh 1))) (vector (vector (+ (* a e) (* b g)) (+ (* a f) (* b h))) (vector (+ (* c e) (* d g)) (+ (* c f) (* d h))))))

#+begin_src elisp
  (let ((m [[0 1] [1 1]]))
    (mm m (mm m (mm m (mm m (mm m m))))))
#+end_src

#+results:
: [[5 8] [8 13]]

#+end_note
*** Rephrase
    Explain what the following code does-
*** Approach
    I executed each code block and then went through and conceptualized how they work.
*** Solution
    The first code block shows how to do a 2 x 2 matrix multiplication.
    The Second code block shows how to access the inner list of a function definition.
    The last code block uses the mm function with a matrix that has [0 1] as its first row
    and [1 1] as its second row.
*** Proof
    5 8 and 13 (fibonacci numbers) are from the matrix being raised to the 6th power.
